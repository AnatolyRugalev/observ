//go:build !gent
// +build !gent

// Code generated by chaingen. DO NOT EDIT.

package gent

import (
	"github.com/AnatolyRugalev/observ/internal/genq"
)

func (s Slice[V]) First() V {
	return s.slice.First()
}

func (s Slice[V]) Last() V {
	return s.slice.Last()
}

func (s Slice[V]) Count() int {
	return s.slice.Count()
}

func (s Slice[V]) Where(operands ...genq.FilterFunc[V]) Filter[V] {
	return s.filter(s.slice.Where(operands...))
}

func (s Slice[V]) Group(fn genq.GroupFunc[string, V]) Group[string, V] {
	return s.group(s.slice.Group(fn))
}

func (s Slice[V]) Merge(slices ...Slice[V]) Slice[V] {
	return s.wrap(s.slice.Merge(new(Slice[V]).gen_unwrap(slices...)...))
}

func (s Slice[V]) Resolve() Slice[V] {
	return s.wrap(s.slice.Resolve())
}

func (Slice[V]) gen_unwrap(in ...Slice[V]) []genq.Slice[V] {
	out := make([]genq.Slice[V], len(in))
	for i := range in {
		out[i] = in[i].unwrap()
	}
	return out
}

func (f Filter[V]) And(operands ...genq.FilterFunc[V]) Filter[V] {
	return f.wrap(f.filter.And(operands...))
}

func (f Filter[V]) Group(fn genq.GroupFunc[string, V]) *genq.Group[string, V] {
	return f.filter.Group(fn)
}

func (f Filter[V]) Merge(slices ...Slice[V]) Slice[V] {
	return f.slice(f.filter.Merge(new(Slice[V]).gen_unwrap(slices...)...))
}

func (f Filter[V]) Last() V {
	return f.filter.Last()
}

func (f Filter[V]) WithFn(fn genq.FilterFunc[V]) Filter[V] {
	return f.wrap(f.filter.WithFn(fn))
}

func (f Filter[V]) Fn() genq.FilterFunc[V] {
	return f.filter.Fn()
}

func (f Filter[V]) Resolve() Slice[V] {
	return f.slice(f.filter.Resolve())
}

func (f Filter[V]) Invert() Filter[V] {
	return f.wrap(f.filter.Invert())
}

func (f Filter[V]) Not(operands ...genq.FilterFunc[V]) Filter[V] {
	return f.wrap(f.filter.Not(operands...))
}

func (f Filter[V]) Or(operands ...genq.FilterFunc[V]) Filter[V] {
	return f.wrap(f.filter.Or(operands...))
}

func (f Filter[V]) Count() int {
	return f.filter.Count()
}

func (f Filter[V]) First() V {
	return f.filter.First()
}

func (g Group[K, V]) Resolve() Slice[V] {
	return g.slice(g.group.Resolve())
}

// Flat returns all items in a group as a slice.
func (g Group[K, V]) Flat() Slice[V] {
	return g.slice(g.group.Flat())
}

// Aggregate performs an aggregation, and returns results as a map
func (g Group[K, V]) Aggregate(fn genq.AggregationFunc[V]) map[K]V {
	return g.group.Aggregate(fn)
}

// AggregateFlat performs an aggregation, and returns results as a slice.
func (g Group[K, V]) AggregateFlat(fn genq.AggregationFunc[V]) Slice[V] {
	return g.slice(g.group.AggregateFlat(fn))
}

// Key returns a list of items grouped by a given key value.
func (g Group[K, V]) Key(key K) Slice[V] {
	return g.slice(g.group.Key(key))
}

// AsMap returns grouped values as a map
func (g Group[K, V]) AsMap() map[K]genq.Slice[V] {
	return g.group.AsMap()
}

func (g Group[K, V]) Merge(groups ...Group[K, V]) Group[K, V] {
	return g.wrap(g.group.Merge(new(Group[K, V]).gen_unwrap(groups...)...))
}

func (g Group[K, V]) Count() int {
	return g.group.Count()
}

func (Group[K, V]) gen_unwrap(in ...Group[K, V]) []*genq.Group[K, V] {
	out := make([]*genq.Group[K, V], len(in))
	for i := range in {
		out[i] = in[i].unwrap()
	}
	return out
}
