//go:build !logt
// +build !logt

// Code generated by chaingen. DO NOT EDIT.

package logt

import (
	"github.com/AnatolyRugalev/observ/internal/genq"
	"github.com/AnatolyRugalev/observ/logq"
)

func (f Filter) Count() int {
	return f.filter.Count()
}

func (f Filter) Not(operands ...logq.FilterFunc) Filter {
	f.filter = f.filter.Not(operands...)
	return f
}

func (f Filter) Attr(key string, value any) Filter {
	f.filter = f.filter.Attr(key, value)
	return f
}

func (f Filter) Merge(slices ...logq.Records) logq.Records {
	return f.filter.Merge(slices...)
}

func (f Filter) Invert() Filter {
	f.filter = f.filter.Invert()
	return f
}

func (f Filter) First() logq.Record {
	return f.filter.First()
}

func (f Filter) Message(message string) Filter {
	f.filter = f.filter.Message(message)
	return f
}

func (f Filter) Group(fn genq.GroupFunc[string, logq.Record]) Group[string] {
	return f.wrapGroup(f.filter.Group(fn))
}

func (f Filter) Last() logq.Record {
	return f.filter.Last()
}

func (f Filter) And(operands ...logq.FilterFunc) Filter {
	f.filter = f.filter.And(operands...)
	return f
}

func (f Filter) Or(operands ...logq.FilterFunc) Filter {
	f.filter = f.filter.Or(operands...)
	return f
}

func (f Filter) Fn() logq.FilterFunc {
	return f.filter.Fn()
}

func (f Filter) WithFn(fn logq.FilterFunc) Filter {
	f.filter = f.filter.WithFn(fn)
	return f
}

func (g Group[K]) Merge(groups ...logq.Group[K]) Group[K] {
	g.group = g.group.Merge(groups...)
	return g
}

func (g Group[K]) Count() int {
	return g.group.Count()
}

// Flat returns all items in a group as a slice.
func (g Group[K]) Flat() logq.Records {
	return g.group.Flat()
}

// Aggregate performs an aggregation, and returns results as a map
func (g Group[K]) Aggregate(fn genq.AggregationFunc[logq.Record]) map[K]logq.Record {
	return g.group.Aggregate(fn)
}

// Key returns a list of items grouped by a given key value.
func (g Group[K]) Key(key K) logq.Records {
	return g.group.Key(key)
}

// AsMap returns grouped values as a map
func (g Group[K]) AsMap() map[K]logq.Records {
	return g.group.AsMap()
}

func (g Group[K]) Resolve() logq.Records {
	return g.group.Resolve()
}

// AggregateFlat performs an aggregation, and returns results as a slice.
func (g Group[K]) AggregateFlat(fn genq.AggregationFunc[logq.Record]) logq.Records {
	return g.group.AggregateFlat(fn)
}
