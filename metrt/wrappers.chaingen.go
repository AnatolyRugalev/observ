//go:build !metrt
// +build !metrt

// Code generated by chaingen. DO NOT EDIT.

package metrt

import (
	"github.com/AnatolyRugalev/observ/internal/genq"
	"github.com/AnatolyRugalev/observ/metrq"
	"github.com/AnatolyRugalev/observ/stats"
)

func (f Metrics) Get() metrq.Metrics {
	return f.filter.Get()
}

func (f Metrics) Where(operands ...genq.FilterFunc[metrq.Metric]) Metrics {
	return f.wrapFilter(f.filter.Where(operands...))
}

func (f Metrics) And(operands ...genq.FilterFunc[metrq.Metric]) Metrics {
	return f.wrapFilter(f.filter.And(operands...))
}

func (f Metrics) Or(operands ...genq.FilterFunc[metrq.Metric]) Metrics {
	return f.wrapFilter(f.filter.Or(operands...))
}

func (f Metrics) First() metrq.Metric {
	return f.filter.First()
}

func (f Metrics) Last() metrq.Metric {
	return f.filter.Last()
}

func (f Metrics) Group(fn genq.GroupFunc[string, metrq.Metric]) Group[string] {
	return f.wrapGroup(f.filter.Group(fn))
}

// Flat returns all items in a group as a slice.
func (g Group[K]) Flat() metrq.Metrics {
	return g.group.Flat()
}

// Aggregate performs an aggregation, and returns results as a map
func (g Group[K]) Aggregate(fn genq.AggregationFunc[metrq.Metric]) map[K]metrq.Metric {
	return g.group.Aggregate(fn)
}

// AggregateFlat performs an aggregation, and returns results as a slice.
func (g Group[K]) AggregateFlat(fn genq.AggregationFunc[metrq.Metric]) metrq.Metrics {
	return g.group.AggregateFlat(fn)
}

// Key returns a list of items grouped by a given key value.
func (g Group[K]) Key(key K) metrq.Metrics {
	return g.group.Key(key)
}

// AsMap returns grouped values as a map
func (g Group[K]) AsMap() map[K]metrq.Metrics {
	return g.group.AsMap()
}

func (g Group[K]) FloatSum() map[K]float64 {
	return g.group.FloatSum()
}

func (g Group[K]) IntSum() map[K]int64 {
	return g.group.IntSum()
}

func (g Group[K]) StatMap(fn stats.StatFunc) map[K]metrq.Metric {
	return g.group.StatMap(fn)
}

func (g Group[K]) Stat(fn stats.StatFunc) metrq.Metrics {
	return g.group.Stat(fn)
}

func (g Group[K]) Float(fn stats.StatFunc) map[K]float64 {
	return g.group.Float(fn)
}

func (g Group[K]) Int(fn stats.StatFunc) map[K]int64 {
	return g.group.Int(fn)
}
