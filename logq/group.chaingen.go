//go:build !logq
// +build !logq

// Code generated by chaingen. DO NOT EDIT.

package logq

import (
	"github.com/AnatolyRugalev/observ/internal/genq"
)

// Key returns a list of items grouped by a given key value.
func (g Group[K]) Key(key K) Records {
	return g.slice(g.group.Key(key))
}

// AsMap returns grouped values as a map
func (g Group[K]) AsMap() map[K]Records {
	return g.sliceMap(g.group.AsMap())
}

func (g Group[K]) Merge(groups ...Group[K]) Group[K] {
	return g.wrap(g.group.Merge(new(Group[K]).gen_unwrap(groups...)...))
}

func (g Group[K]) Count() int {
	return g.group.Count()
}

func (g Group[K]) Resolve() Records {
	return g.slice(g.group.Resolve())
}

// Flat returns all items in a group as a slice.
func (g Group[K]) Flat() Records {
	return g.slice(g.group.Flat())
}

// Aggregate performs an aggregation, and returns results as a map
func (g Group[K]) Aggregate(fn genq.AggregationFunc[Record]) map[K]Record {
	return g.group.Aggregate(fn)
}

// AggregateFlat performs an aggregation, and returns results as a slice.
func (g Group[K]) AggregateFlat(fn genq.AggregationFunc[Record]) Records {
	return g.slice(g.group.AggregateFlat(fn))
}

func (Group[K]) gen_unwrap(in ...Group[K]) []*genq.Group[K, Record] {
	out := make([]*genq.Group[K, Record], len(in))
	for i := range in {
		out[i] = in[i].unwrap()
	}
	return out
}
